{"version":3,"sources":["ng://@digitalascetic/ngx-pica/lib/ngx-pica-error.interface.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica-exif.service.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica.service.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica-image.service.ts","ng://@digitalascetic/ngx-pica/lib/ngx-pica.module.ts"],"names":["NgxPicaExifService","prototype","getExifOrientedImage","image","Promise","resolve","reject","EXIF.getData","exifOrientation","EXIF.getAllTags","Orientation","test","Error","canvas","document","createElement","ctx","getContext","deg","cx","cy","width","height","indexOf","translate","scale","rotate","Math","PI","drawImage","img_1","Image","onload","src","toDataURL","Injectable","NgxPicaService","_ngxPicaExifService","this","picaResizer","Pica","MAX_STEPS","resize","resizeImages","files","options","_this","resizedImage","Subject","totalFiles","length","nextFile_1","index_1","subscription_1","subscribe","file","resizeImage","imageResized","next","complete","unsubscribe","err","ngxPicaError","error","NgxPicaErrorType","asObservable","originCanvas","img","then","orientedImage","window","URL","revokeObjectURL","imageData","getImageData","aspectRatio","keepAspectRatio","ratio","forceMinDimensions","max","min","round","destinationCanvas","picaResize","imgResized","catch","createObjectURL","compressImages","sizeInMB","compressedImage","nextFile_2","index_2","subscription_2","compressImage","imageCompressed","bytesToMB","size","setTimeout","originCanvas_1","ctx_1","getCompressedImage","type","blob","imgCompressed","blobToFile","name","Date","getTime","quality","step","toBlob","checkCompressedImageSize","compressedBlob","newQuality","newStep","from","to","resizedCanvas","fileResized","lastModified","File","bytes","NgxPicaImageService","imageExtensions","isImage","fileExtension","toLowerCase","substr","lastIndexOf","NgxPicaModule","NgModule","args","providers","provide","useClass"],"mappings":"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,OAAAvE,EAAKP,YAAYuE,OAAOO,EAAe9D,EAAK8C,QACvFjC,KAAI,SAAEkC,OACGgB,EAAoBxE,EAAK0D,WAAWF,EAAM/C,EAAKkD,KAAMlD,EAAK8C,MAAM,IAAIK,MAAOC,WACjFtG,EAAQiH,QAKhBlF,EAAAnC,UAAAuG,WAAR,SAAmBF,EAAYG,EAAcJ,EAAckB,GACvD,OAAO,IAAIC,KAAK,CAAClB,GAAOG,EAAM,CAAEJ,KAAMA,EAAMkB,aAAcA,KAGtDnF,EAAAnC,UAAA8F,UAAR,SAAkB0B,GACd,OAAOA,EAAQ,6BAlPtBtF,EAAAA,sDALQnC,KAyPToC,EA7PA,GCAAsF,EAAA,WAEA,SAAAA,IAGYpF,KAAAqF,gBAA4B,CAChC,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,OACA,KACA,MACA,OACA,MACA,MACA,MACA,OAOR,OAJWD,EAAAzH,UAAA2H,QAAP,SAAerE,OACLsE,EAAwBtE,EAAKkD,KAAKqB,cAAcC,OAAOxE,EAAKkD,KAAKuB,YAAY,KAAO,GAC1F,OAAyD,IAAjD1F,KAAKqF,gBAAgBpG,QAAQsG,wBAhI5C1F,EAAAA,aAkIDuF,EApIA,GCAAO,EAAA,WAKA,SAAAA,KAO6B,2BAP5BC,EAAAA,SAAQC,KAAA,CAAC,CACNC,UAAW,CACP,CAAEC,QAASjG,EAAgBkG,SAAUlG,GACrC,CAAEiG,QAASrI,EAAoBsI,SAAUtI,GACzC,CAAEqI,QAASX,EAAqBY,SAAUZ,QAGrBO,EAZ7B","sourcesContent":["export enum NgxPicaErrorType {\n    NO_FILES_RECEIVED = 'NO_FILES_RECEIVED',\n    CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED = 'CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED',\n    NOT_BE_ABLE_TO_COMPRESS_ENOUGH = 'NOT_BE_ABLE_TO_COMPRESS_ENOUGH'\n}\n\nexport interface NgxPicaError {\n    err: NgxPicaErrorType;\n    file?: File;\n}\n","import { Injectable } from '@angular/core';\nimport * as EXIF from 'exif-js';\n\n@Injectable()\nexport class NgxPicaExifService {\n\n    public getExifOrientedImage(image: HTMLImageElement): Promise<HTMLImageElement> {\n        return new Promise<HTMLImageElement>((resolve, reject) => {\n            EXIF.getData((image as any), () => {\n                const allExifMetaData = EXIF.getAllTags(image),\n                    exifOrientation = allExifMetaData.Orientation;\n\n                if (exifOrientation) {\n\n                    if (!/^[1-8]$/.test(exifOrientation)) {\n                        throw new Error('orientation should be [1-8]');\n                    }\n\n                    const canvas: HTMLCanvasElement = document.createElement('canvas'),\n                        ctx = canvas.getContext('2d');\n\n                    let deg = 0,\n                        cx = 0,\n                        cy = 0,\n                        width: number = image.width,\n                        height: number = image.height;\n\n                    if ([5, 6, 7, 8].indexOf(exifOrientation) > -1) {\n                        width = image.height;\n                        height = image.width;\n                    }\n\n                    canvas.width = width;\n                    canvas.height = height;\n\n                    switch (exifOrientation) {\n                        case 3:\n                        case 4:\n                            cx = -image.width;\n                            cy = -image.height;\n                            deg = 180;\n                            break;\n                        case 5:\n                        case 6:\n                            cy = -image.height;\n                            deg = 90;\n                            break;\n                        case 7:\n                        case 8:\n                            cx = -image.width;\n                            deg = 270;\n                            break;\n                        default:\n                            break;\n                    }\n\n                    if ([2, 4, 5, 7].indexOf(exifOrientation) > -1) {\n                        ctx.translate(width, 0);\n                        ctx.scale(-1, 1);\n                    }\n\n                    ctx.rotate(deg / 180 * Math.PI);\n                    ctx.drawImage(image, cx, cy);\n\n                    const img = new Image();\n\n                    img.width = width;\n                    img.height = height;\n\n                    img.onload = () => {\n                        resolve(img);\n                    };\n\n                    img.src = canvas.toDataURL();\n                } else {\n                    resolve(image);\n                }\n            });\n        });\n    }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Subject, Observable, Subscription } from 'rxjs';\nimport { NgxPicaError, NgxPicaErrorType } from './ngx-pica-error.interface';\nimport { NgxPicaResizeOptions } from './ngx-pica-resize-options.interface';\nimport { NgxPicaExifService } from './ngx-pica-exif.service';\nimport Pica from 'pica/dist/pica.js';\n\ndeclare let window: any;\n\n@Injectable()\nexport class NgxPicaService {\n    private picaResizer = new Pica();\n    private MAX_STEPS = 20;\n\n    constructor(private _ngxPicaExifService: NgxPicaExifService) {\n        if (!this.picaResizer || !this.picaResizer.resize) {\n            this.picaResizer = new Pica();\n        }\n    }\n\n    public resizeImages(\n        files: File[],\n        width: number,\n        height: number,\n        options?: NgxPicaResizeOptions\n    ): Observable<File> {\n        const resizedImage: Subject<File> = new Subject();\n        const totalFiles: number = files.length;\n\n        if (totalFiles > 0) {\n            const nextFile: Subject<File> = new Subject();\n            let index = 0;\n\n            const subscription: Subscription = nextFile.subscribe((file: File) => {\n                this.resizeImage(file, width, height, options).subscribe(imageResized => {\n                    index++;\n                    resizedImage.next(imageResized);\n                    if (index < totalFiles) {\n                        nextFile.next(files[index]);\n                    } else {\n                        resizedImage.complete();\n                        subscription.unsubscribe();\n                    }\n                }, (err) => {\n                    const ngxPicaError: NgxPicaError = {\n                        file: file,\n                        err: err\n                    };\n\n                    resizedImage.error(ngxPicaError);\n                });\n            });\n\n            nextFile.next(files[index]);\n        } else {\n            const ngxPicaError: NgxPicaError = {\n                err: NgxPicaErrorType.NO_FILES_RECEIVED\n            };\n            resizedImage.error(ngxPicaError);\n            resizedImage.complete();\n        }\n\n        return resizedImage.asObservable();\n    }\n\n    public resizeImage(\n        file: File,\n        width: number,\n        height: number,\n        options?: NgxPicaResizeOptions\n    ): Observable<File> {\n        const resizedImage: Subject<File> = new Subject();\n        const originCanvas: HTMLCanvasElement = document.createElement('canvas');\n        const ctx = originCanvas.getContext('2d');\n        const img = new Image();\n\n        if (ctx) {\n            img.onload = () => {\n                this._ngxPicaExifService.getExifOrientedImage(img).then(orientedImage => {\n                    window.URL.revokeObjectURL(img.src);\n                    originCanvas.width = orientedImage.width;\n                    originCanvas.height = orientedImage.height;\n\n                    ctx.drawImage(orientedImage, 0, 0);\n\n                    const imageData = ctx.getImageData(0, 0, orientedImage.width, orientedImage.height);\n                    if (options && options.aspectRatio && options.aspectRatio.keepAspectRatio) {\n                        let ratio = 0;\n                        if (options.aspectRatio.forceMinDimensions) {\n                            ratio = Math.max(width / imageData.width, height / imageData.height);\n                        } else {\n                            ratio = Math.min(width / imageData.width, height / imageData.height);\n                        }\n                        width = Math.round(imageData.width * ratio);\n                        height = Math.round(imageData.height * ratio);\n                    }\n\n                    const destinationCanvas: HTMLCanvasElement = document.createElement('canvas');\n                    destinationCanvas.width = width;\n                    destinationCanvas.height = height;\n\n                    this.picaResize(file, originCanvas, destinationCanvas, options)\n                        .then((imgResized: File) => resizedImage.next(imgResized))\n                        .catch((err) => resizedImage.error(err));\n                });\n            };\n            img.src = window.URL.createObjectURL(file);\n        } else {\n            resizedImage.error(NgxPicaErrorType.CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED);\n        }\n\n        return resizedImage.asObservable();\n    }\n\n    public compressImages(files: File[], sizeInMB: number): Observable<File> {\n        const compressedImage: Subject<File> = new Subject();\n        const totalFiles: number = files.length;\n\n        if (totalFiles > 0) {\n            const nextFile: Subject<File> = new Subject();\n            let index = 0;\n\n            const subscription: Subscription = nextFile.subscribe((file: File) => {\n                this.compressImage(file, sizeInMB).subscribe(imageCompressed => {\n                    index++;\n                    compressedImage.next(imageCompressed);\n                    if (index < totalFiles) {\n                        nextFile.next(files[index]);\n                    } else {\n                        compressedImage.complete();\n                        subscription.unsubscribe();\n                    }\n                }, (err) => {\n                    const ngxPicaError: NgxPicaError = {\n                        file: file,\n                        err: err\n                    };\n                    compressedImage.error(ngxPicaError);\n                });\n            });\n\n            nextFile.next(files[index]);\n        } else {\n            const ngxPicaError: NgxPicaError = {\n                err: NgxPicaErrorType.NO_FILES_RECEIVED\n            };\n            compressedImage.error(ngxPicaError);\n            compressedImage.complete();\n        }\n\n        return compressedImage.asObservable();\n    }\n\n    public compressImage(file: File, sizeInMB: number): Observable<File> {\n        const compressedImage: Subject<File> = new Subject();\n\n        if (this.bytesToMB(file.size) <= sizeInMB) {\n            setTimeout(() => compressedImage.next(file));\n        } else {\n            const originCanvas: HTMLCanvasElement = document.createElement('canvas');\n            const ctx = originCanvas.getContext('2d');\n            const img = new Image();\n\n            if (ctx) {\n                img.onload = () => {\n                    this._ngxPicaExifService.getExifOrientedImage(img).then(orientedImage => {\n                        window.URL.revokeObjectURL(img.src);\n                        originCanvas.width = orientedImage.width;\n                        originCanvas.height = orientedImage.height;\n\n                        ctx.drawImage(orientedImage, 0, 0);\n\n                        this.getCompressedImage(originCanvas, file.type, 1, sizeInMB, 0)\n                            .catch((err) => compressedImage.error(err))\n                            .then((blob: Blob) => {\n                                const imgCompressed: File = this.blobToFile(blob, file.name, file.type, new Date().getTime());\n                                compressedImage.next(imgCompressed);\n                            });\n                    });\n                };\n\n                img.src = window.URL.createObjectURL(file);\n            } else {\n                compressedImage.error(NgxPicaErrorType.CANVAS_CONTEXT_IDENTIFIER_NOT_SUPPORTED);\n            }\n        }\n\n        return compressedImage.asObservable();\n    }\n\n    private getCompressedImage(\n        canvas: HTMLCanvasElement,\n        type: string,\n        quality: number,\n        sizeInMB: number,\n        step: number\n    ): Promise<Blob> {\n        return new Promise<Blob>((resolve, reject) => {\n            this.picaResizer.toBlob(canvas, type, quality)\n                .catch((err) => reject(err))\n                .then((blob: Blob) => {\n                    this.checkCompressedImageSize(canvas, blob, quality, sizeInMB, step)\n                        .then((compressedBlob: Blob) => resolve(compressedBlob))\n                        .catch((err) => reject(err));\n                });\n        });\n    }\n\n    private checkCompressedImageSize(\n        canvas: HTMLCanvasElement,\n        blob: Blob,\n        quality: number,\n        sizeInMB: number,\n        step: number\n    ): Promise<Blob> {\n        return new Promise<Blob>((resolve, reject) => {\n            if (step > this.MAX_STEPS) {\n                reject(NgxPicaErrorType.NOT_BE_ABLE_TO_COMPRESS_ENOUGH);\n            } else if (this.bytesToMB(blob.size) < sizeInMB) {\n                resolve(blob);\n            } else {\n                const newQuality: number = quality - (quality * 0.1);\n                const newStep: number = step + 1;\n                // recursively compression\n                resolve(this.getCompressedImage(canvas, blob.type, newQuality, sizeInMB, newStep));\n            }\n        });\n    }\n\n    private picaResize(\n        file: File,\n        from: HTMLCanvasElement,\n        to: HTMLCanvasElement,\n        options: any\n    ): Promise<File> {\n        return new Promise<File>((resolve, reject) => {\n            this.picaResizer.resize(from, to, options)\n                .catch((err) => reject(err))\n                .then((resizedCanvas: HTMLCanvasElement) => this.picaResizer.toBlob(resizedCanvas, file.type))\n                .then((blob: Blob) => {\n                    const fileResized: File = this.blobToFile(blob, file.name, file.type, new Date().getTime());\n                    resolve(fileResized);\n                });\n        });\n    }\n\n    private blobToFile(blob: Blob, name: string, type: string, lastModified: number): File {\n        return new File([blob], name, { type: type, lastModified: lastModified });\n    }\n\n    private bytesToMB(bytes: number) {\n        return bytes / 1048576;\n    }\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class NgxPicaImageService {\n\n    private imageExtensions: string[] = [\n        'ase',\n        'art',\n        'bmp',\n        'blp',\n        'cd5',\n        'cit',\n        'cpt',\n        'cr2',\n        'cut',\n        'dds',\n        'dib',\n        'djvu',\n        'egt',\n        'exif',\n        'gif',\n        'gpl',\n        'grf',\n        'icns',\n        'ico',\n        'iff',\n        'jng',\n        'jpeg',\n        'jpg',\n        'jfif',\n        'jp2',\n        'jps',\n        'lbm',\n        'max',\n        'miff',\n        'mng',\n        'msp',\n        'nitf',\n        'ota',\n        'pbm',\n        'pc1',\n        'pc2',\n        'pc3',\n        'pcf',\n        'pcx',\n        'pdn',\n        'pgm',\n        'PI1',\n        'PI2',\n        'PI3',\n        'pict',\n        'pct',\n        'pnm',\n        'pns',\n        'ppm',\n        'psb',\n        'psd',\n        'pdd',\n        'psp',\n        'px',\n        'pxm',\n        'pxr',\n        'qfx',\n        'raw',\n        'rle',\n        'sct',\n        'sgi',\n        'rgb',\n        'int',\n        'bw',\n        'tga',\n        'tiff',\n        'tif',\n        'vtf',\n        'xbm',\n        'xcf',\n        'xpm',\n        '3dv',\n        'amf',\n        'ai',\n        'awg',\n        'cgm',\n        'cdr',\n        'cmx',\n        'dxf',\n        'e2d',\n        'egt',\n        'eps',\n        'fs',\n        'gbr',\n        'odg',\n        'svg',\n        'stl',\n        'vrml',\n        'x3d',\n        'sxd',\n        'v2d',\n        'vnd',\n        'wmf',\n        'emf',\n        'art',\n        'xar',\n        'png',\n        'webp',\n        'jxr',\n        'hdp',\n        'wdp',\n        'cur',\n        'ecw',\n        'iff',\n        'lbm',\n        'liff',\n        'nrrd',\n        'pam',\n        'pcx',\n        'pgf',\n        'sgi',\n        'rgb',\n        'rgba',\n        'bw',\n        'int',\n        'inta',\n        'sid',\n        'ras',\n        'sun',\n        'tga'\n    ];\n\n    public isImage(file: File): boolean {\n        const fileExtension: string = file.name.toLowerCase().substr(file.name.lastIndexOf('.') + 1);\n        return (this.imageExtensions.indexOf(fileExtension) !== -1);\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { NgxPicaService } from './ngx-pica.service';\nimport { NgxPicaExifService } from './ngx-pica-exif.service';\nimport { NgxPicaImageService } from './ngx-pica-image.service';\n\n@NgModule({\n    providers: [\n        { provide: NgxPicaService, useClass: NgxPicaService },\n        { provide: NgxPicaExifService, useClass: NgxPicaExifService },\n        { provide: NgxPicaImageService, useClass: NgxPicaImageService },\n    ]\n})\nexport class NgxPicaModule { }\n"]}